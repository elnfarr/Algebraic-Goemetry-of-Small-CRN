#To read in the CRNs from the onine database, we used the following functions to convert the list of numbers into a list of CRNs.
#The edges listed in the data is converted into LHS (L2) and RHS (R2) matrices that represent the coefficients of the CRNs.
#These L2 and R2 are then turned into one large matrix which houses all of the CRNs from the original file.
#Before use, need to load the ReactionNetworks and ReflexivePolytopesDB packages.
#Here, the loaded file was called "fn3".

get fn3;

codes = apply(lines get fn3, s-> flatten entries matrixFromString s)
edges = for c in codes list(t = drop(c, 2); while #t > 0 list (t_0, t_1) do t = drop(t,2))   
m = (codes_0)_0
n = (codes_0)_1

R = matrix table(n,m, (i,j) -> number(edges_0, e -> e == (j,i+m)) ) 
L = matrix table(n,m, (i,j) -> number(edges_0, e -> e == (i+m,j)) ) 
#Formats the edges list into of text file rows into columns of CRN coefficients
                            
R2 = apply (edges, f -> matrix table(n,m, (i,j) -> number(f, e -> e == (j,i+m)) ));
L2 = apply (edges, f -> matrix table(n,m, (i,j) -> number(f, e -> e == (i+m,j)) ));

crnRing = QQ[A, B]
varMatrix = vars crnRing
makeCRN = (m, LHS, RHS) -> (
    myList = apply (m, i -> concatenate(toString((flatten entries LHS_0)_i), " --> ", toString((flatten entries RHS_0)_i)) ); --concatenates and formats the CRNs
    myList2 = apply (m, i -> concatenate separate("[*]", myList_i)); --removes star
    myCRN = reactionNetwork apply(myList2, s -> replace( "0", "0A", s )) --changes 0 into o times a variable
    )

#Due to our llimited computing power, we split the original data into four parts and ran the functions for each part individually.
#An example of this is below for clarity incase you run into the same problem.

Iteration = for g from 0 to 52 list makeCRN(m, varMatrix*(L2_{g}), varMatrix*(R2_{g}))
